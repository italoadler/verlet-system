var number = require('as-number')
var clamp = require('clamp')
var createCollider = require('./box-collision')

var noop = function noop() {}

module.exports = function create(vec) {
    
    var collide = createCollider(vec)

    var velocity = vec.create()
    var tmp = vec.create()
    var zero = vec.create()
    
    function System(opt) {
        if (!(this instanceof System))
            return new System(opt)
        
        opt = opt||{}

        this.gravity = opt.gravity || vec.create()
        this.friction = number(opt.friction, 0.98)
        this.min = opt.min
        this.max = opt.max
        this.bounce = number(opt.bounce, 1)
    }
    
    System.prototype.collision = function(p, velocity) {
        collide(p, velocity, this.min, this.max, this.bounce)
    }

    System.prototype.integratePoint = function(point, delta) {
        var mass = typeof point.mass === 'number' ? point.mass : 1

        //if mass is zero, assume body is static / unmovable
        if (mass === 0) {
            this.collision(point, zero)
            vec.copy(point.acceleration, zero)
            return
        }

        vec.add(point.acceleration, point.acceleration, this.gravity)
        vec.scale(point.acceleration, point.acceleration, mass)
            
        //difference in positions
        vec.sub(velocity, point.position, point.previous)

        //dampen velocity
        vec.scale(velocity, velocity, this.friction)

        //handle custom collisions in 2D or 3D space
        this.collision(point, velocity)

        //set last position
        vec.copy(point.previous, point.position)
        var tSqr = delta * delta
            
        //integrate
        vec.scale(tmp, point.acceleration, 0.5 * tSqr)
        vec.add(point.position, point.position, velocity)
        vec.add(point.position, point.position, tmp)

        //reset acceleration
        vec.copy(point.acceleration, zero)
    }

    System.prototype.integrate = function(points, delta) {
        for (var i=0; i<points.length; i++) {
            this.integratePoint(points[i], delta)
        }
    }

    return System
}